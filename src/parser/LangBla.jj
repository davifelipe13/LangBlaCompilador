options {  STATIC = false;  DEBUG_LOOKAHEAD = true;}PARSER_BEGIN(langBla)package parser;import java.io.*;import recovery.*; //importa as classes de recuperação de erros do AS=public class langBla {  final static String Version = "B+- Compiler - Version 1.0 - 2018";int contParseError = 0;           // contador de erros sintáticosboolean debug_recovery;   // controla verbose de recuperação de errosToken lastError = null;// Define o método "main" da classe langBla.    public  static void main(String args[]) throws ParseException   {  boolean debug_as = false;  boolean debug_recovery = false;    String filename = ""; // nome do arquivo a ser analisado    langBla parser;     // analisador léxico/sintático    int i;    boolean ms = false;    System.out.println(Version);    // lê os parâmetros passados para o compilador    for (i = 0; i < args.length - 1; i++)    {        if (args[i].equals("-debug_AS") )            debug_as = true;        else        if (args[i].equals("-debug_recovery") )            debug_recovery = true;        else        {            System.out.println("Usage is: java langBla [-debug_AS] " +             "[-debug_recovery] inputfile");            System.exit(0);        }    }    if (args[i].equals("-"))    {       // lê da entrada padrão              System.out.println("Reading from standard input . . .");        parser = new langBla(System.in); // cria AS     }     else     {       // lê do arquivo        filename = args[args.length-1];          System.out.println("Reading from file " + filename + " . . .");        try {  // cria AS            parser = new langBla(new java.io.FileInputStream(filename));        }     catch (java.io.FileNotFoundException e) {               System.out.println("File " + filename + " not found.");        return;        }    }     parser.debug_recovery = debug_recovery;    if (! debug_as) parser.disable_tracing(); // desab. verbose do AS    try {        parser.program();   // chama o método que faz a análise    }    catch (ParseEOFException e)    {    System.err.println(e.getMessage());    }    finally {        System.out.println(parser.token_source.foundLexError() +                                " Lexical Errors found");        System.out.println(parser.contParseError + " Syntactic Errors found");     }}  // mainstatic public String im(int x){int k;String s;   s = tokenImage[x];   k = s.lastIndexOf("\"");   try {s = s.substring(1,k);}   catch (StringIndexOutOfBoundsException e)   {}   return s;}boolean eof;    // variável que indica se EOF foi alcançado// o método abaixo consome tokens até alcançar um que pertença ao conjunto// de sincronizaçãovoid consumeUntil(RecoverySet g,                 ParseException e,                 String met) throws ParseEOFException,                                    ParseException{Token tok;   if ( debug_recovery) // informação sobre a recuperação   {       System.out.println();       System.out.println("*** " + met + " ***");       System.out.println("     Syncronizing Set: " + g);   }   if (g == null) throw e; // se o conjunto é null, propaga a exceção   tok = getToken(1); // pega token corrente   while ( ! eof )  // se não chegou ao fim do arquivo   {        if ( g.contains(tok.kind ) ) //achou um token no conjunto        {             if ( debug_recovery)               System.out.println("     Found syncronizing token: " +                                    im(tok.kind));             break;        }        if (debug_recovery)             System.out.println("     Ignoring token: " + im(tok.kind));        getNextToken();     // pega próximo token               tok = getToken(1);        if (tok.kind == EOF && ! g.contains(EOF) ) // fim da entrada?               eof = true;    }   if ( tok != lastError)   {        System.out.println(e.getMessage());        lastError = tok;        contParseError++;  // incrementa número de erros   }   if ( eof ) throw new ParseEOFException("EOF found prematurely.");}}  // langBlaPARSER_END(langBla)TOKEN_MGR_DECLS :{int countLexError = 0;public int foundLexError() {    return countLexError;}}SKIP :{  " "| "\r"| "\t"| "\n"| "\f"}SKIP :{  "/*": multilinecomment //ao encontrar um /* o AL vai para o estado multilinecomment, ignorando tudo que venha ate o fim do estado| "//": singlelinecomment}<multilinecomment> SKIP:{  "*/": DEFAULT //ao encontrar um */ acha o fim do estado multilinecomment e volta para o estado padrao do AL| <~[]>}<singlelinecomment> SKIP:{  <["\n","\r"]>: DEFAULT| <~[]>}TOKEN : /* Palavras reservadas */{< BREAK: "break" >| < CLASS: "class" >| < CONSTRUCTOR: "constructor" >| < ELSE: "else" >| < EXTENDS: "extends" >| < FOR: "for" >| < IF: "if" >| < INT: "int" >| < FLOAT: "float" >| < BOOLEAN: "boolean" >| < CHAR : "char" >| < NEW: "new" >| < PRINT: "print" >| < READ: "read" >| < RETURN: "return" >| < STRING: "string" >| < SUPER: "super" >}TOKEN : /* Operadores */{  < ASSIGN: "=">| < GT: ">" >| < LT: "<" >| < EQ: "==" >| < LE: "<=" >| < GE: ">=" >| < NEQ: "!=" >| < PLUS : "+" >| < MINUS : "-" >| < MULTIPLY : "*" > //STAR no livro| < DIVIDE : "/" > //SLASH no livro| < REM: "%" >| < NOT: "not" >| < AND: "and" >| < OR: "or" >| < XOR: "xor" >}TOKEN : /* simbolos especiais */{  < RPAREN: ")" >| < LPAREN: "(" >| < LBRACE: "{" >| < RBRACE: "}" >| < LBRACKET: "[" >| < RBRACKET: "]" >| < SEMICOLON: ";" >| < COMMA: "," >| < DOT: "." > }TOKEN : /* Constantes */{//numeros decimais< int_constant: (  (["0"-"9"] (["0"-"9"])*)) > |// reconhecimento de ponto flutuante, float< float_constant: (  (["0"-"9"] (["0"-"9"])* ["."] ["0"-"9"] (["0"-"9"])*)) > |//reconhecimento de boolean< boolean_constant: "true" | "false" > //reconhecimento de string| < string_constant: "\""( ~["\"","\n","\r"])* "\"" >//reconhecimento de char| < char_constant: "\'"( ~["\'"," ","\r"]) "\'" | "\'" ("\\n") "\'" >// reconhecimento de nulo| < null_constant: "null" > }/* Identificadores */TOKEN:{  < IDENT: < LETTER > (< LETTER >|< DIGIT >)* >| < CONSTANT : (< DIGIT >)+ >| < #LETTER:["A"-"Z","a"-"z"] >| < #DIGIT:["0"-"9"] >}/* Tratamento de erros lexicos */SPECIAL_TOKEN:{<INVALID_LEXICAL:(~ ["a"-"z", "A"-"Z", "0"-"9", "\"", "(", ")", "[", "]", "{", "}", ";", ",", ".", "=", ">", "<", "!", "+", "-","*", "/", "%", " ", "\t", "\n", "\r", "\f","\'"])+ >  {    System.err.println("Line " + input_stream.getEndLine() + " - Invalid string found: " + image);    countLexError++;  }|  <INVALID_CONST:  "\"" (~ ["\n", "\r", "\""])* ["\n", "\r"] >    {    System.err.println("Line " + input_stream.getEndLine() + " - String constant has a \\n: " + image);    countLexError++;  }|    <INVALID_CHAR:     "\'" (~ ["\n", "\'"])* ["\r"] >    {    System.err.println("Line " + input_stream.getEndLine() + " - char constant has a \\r:" + image);    countLexError++;  }|       <EMPTY_CHAR:     "\'" "\'" | "\'"(" ")+"\'">    {    System.err.println("Line " + input_stream.getEndLine() + " - char constant is empty " + image);    countLexError++;  }|  < CHAR_OUT_OF_BOUNDS:    "\'"( ~["\'","\r"])( ~["\'","\r"])+ "\'" >{    System.err.println("Line " + input_stream.getEndLine() + " - char constant is out of bounds " + image);    countLexError++;  }}    void program() throws ParseEOFException :{RecoverySet g = new RecoverySet(EOF);	}{	try{		[ classlist(g) ] <EOF>	}	catch (ParseException e){		consumeUntil (g, e, "program");	}    }void classlist(RecoverySet g) throws ParseEOFException :{RecoverySet f = First.classlist.union(g);}{   classdecl(f) [ classlist(g) ]}void classdecl(RecoverySet g) throws ParseEOFException :{}{try {   <CLASS>  <IDENT> [ <EXTENDS> <IDENT> ] classbody(g)}catch (ParseException e){    consumeUntil(g, e, "classdecl");}}void classbody(RecoverySet g) throws ParseEOFException :{RecoverySet f1 = new RecoverySet(RBRACE),			f2 = new RecoverySet(SEMICOLON),            f3 = First.methoddecl.union(f1),            f4 = First.constructdecl.union(f3),            f5 = First.vardecl.union(f4);}{try {   <LBRACE>      [classlist(f5)]      (LOOKAHEAD(3) vardecl(f2) <SEMICOLON>)*      (constructdecl(f4))*      (methoddecl(f3))*   <RBRACE>}catch (ParseException e){   consumeUntil(g, e, "classbody");}}//nao tem no capitulo firstcall e recursivecall//void firstcall():
//{
//}
//{
//	recursivecall()[firstcall()]
//}
//
//void recursivecall():
//{                         
//}
//{
//  	LOOKAHEAD(3) atribstat() < SEMICOLON >
//	| 
//	LOOKAHEAD(3)vardecl() < SEMICOLON >
//	|
//	constructdecl()
//	|
//	methoddecl()
//}
//ver se pode deixar boolean e char no vardclvoid vardecl(RecoverySet g) throws ParseEOFException :{}{try {  (<INT> |  <STRING> | <BOOLEAN> |  <CHAR> | <IDENT> )    <IDENT> ( <LBRACKET> <RBRACKET>)*   (<COMMA> <IDENT> ( <LBRACKET> <RBRACKET>)* )*  }catch (ParseException e){   consumeUntil(g, e, "vardecl");}}void constructdecl(RecoverySet g) throws ParseEOFException :{}{try {    <CONSTRUCTOR> methodbody(g)}catch (ParseException e){   consumeUntil(g, e, "constructdecl");}}void methoddecl(RecoverySet g) throws ParseEOFException :{}{try {   (<INT> |  <STRING> | <BOOLEAN> |  <CHAR> | <IDENT> ) (<LBRACKET> <RBRACKET>)*    <IDENT> methodbody(g)}catch (ParseException e){   consumeUntil(g, e, "methoddecl");}}void methodbody(RecoverySet g) throws ParseEOFException :{RecoverySet f = new RecoverySet(RPAREN);}{try {    <LPAREN> paramlist(f) <RPAREN> statement(g)}catch (ParseException e){   consumeUntil(g, e, "methodbody");}}void paramlist(RecoverySet g) throws ParseEOFException :{}{try {   [    (<INT> |  <STRING> | <BOOLEAN> | <CHAR> | <IDENT>) <IDENT> (<LBRACKET> <RBRACKET>)*     (<COMMA> (<INT> |  <STRING> |  <BOOLEAN> | <CHAR> | <IDENT>) <IDENT> (<LBRACKET> <RBRACKET>)* )*   ]}catch (ParseException e){   consumeUntil(g, e, "paramlist");}}//nao tinha tambem esse atribstatparamlist//void atribstatparamlist():
//{
//}
//{
//	[<ASSIGN> (alocexpression() | expression())]
//}
void statement(RecoverySet g) throws ParseEOFException :{RecoverySet f1 = new RecoverySet(SEMICOLON);RecoverySet f2 = new RecoverySet(RBRACE);}{try {    LOOKAHEAD(2)    vardecl(f1) <SEMICOLON> |    atribstat(f1) <SEMICOLON> |    printstat(f1) <SEMICOLON>|    readstat(f1) <SEMICOLON>|    returnstat(f1) <SEMICOLON>|    superstat(f1) <SEMICOLON>|    ifstat(g) |    forstat(g) |    <LBRACE> statlist(f2) <RBRACE> |    <BREAK> <SEMICOLON>|    <SEMICOLON>}catch (ParseException e){   consumeUntil(g, e, "statement");}}void atribstat(RecoverySet g) throws ParseEOFException :{RecoverySet f1 = new RecoverySet(ASSIGN);}{try {    lvalue(f1) <ASSIGN> ( alocexpression(g) | expression(g))}catch (ParseException e){   consumeUntil(g, e, "atribstat");}}void printstat(RecoverySet g) throws ParseEOFException :{}{try {    <PRINT> expression(g)}catch (ParseException e){   consumeUntil(g, e, "printstat");}}void readstat(RecoverySet g) throws ParseEOFException :{}{try {    <READ> lvalue(g)}catch (ParseException e){   consumeUntil(g, e, "readstat");}}void returnstat(RecoverySet g) throws ParseEOFException :{}{try {    <RETURN> [expression(g)]}catch (ParseException e){   consumeUntil(g, e, "returnstat");}}void superstat(RecoverySet g) throws ParseEOFException :{RecoverySet f = new RecoverySet(RPAREN);}{try {    <SUPER> <LPAREN> arglist(f) <RPAREN>}catch (ParseException e){   consumeUntil(g, e, "superstat");}}void ifstat(RecoverySet g) throws ParseEOFException :{RecoverySet f1 = new RecoverySet(RPAREN),            f2 = new RecoverySet(ELSE).union(g);}{try {    <IF> <LPAREN> expression(f1) <RPAREN> statement(f2)    [LOOKAHEAD(1) <ELSE> statement(g)]}catch (ParseException e){   consumeUntil(g, e, "ifstat");}}void forstat(RecoverySet g) throws ParseEOFException :{RecoverySet f1 = new RecoverySet(SEMICOLON),            f2 = new RecoverySet(RPAREN);}{try {    <FOR> <LPAREN> [atribstat(f1)] <SEMICOLON>                   [expression(f1)] <SEMICOLON>                   [atribstat(f2)] <RPAREN>                    statement(g)}catch (ParseException e){   consumeUntil(g, e, "forstat");}}void  statlist(RecoverySet g) throws ParseEOFException :{RecoverySet f = First.statlist.union(g);}{   statement(f) [ statlist(g)] }void lvalue(RecoverySet g) throws ParseEOFException :{}{try {   <IDENT> (           <LBRACKET> expression(null) <RBRACKET> |           <DOT> <IDENT> [<LPAREN> arglist(null) <RPAREN>]         )*}catch (ParseException e){   consumeUntil(g, e, "lvalue");}}void alocexpression(RecoverySet g) throws ParseEOFException :{RecoverySet f1 = new RecoverySet(RPAREN),            f2 = new RecoverySet(RBRACKET);}{    <NEW> (             LOOKAHEAD(2) <IDENT> <LPAREN> arglist(f1) <RPAREN> |             ( <INT> | <STRING> | <IDENT> )             (<LBRACKET> expression(f2) <RBRACKET>)+          )} //LIVRO PROGRAM 4.13//não tem esse firstprecedencevoid firstprecedence() throws ParseEOFException :{}{[<NOT>] fourthprecedence() [(<XOR>|<OR>) [<NOT>] fourthprecedence()]}//não tem esse fourthprecedencevoid fourthprecedence() throws ParseEOFException :{}{  thirdprecedence() [( <LT> | <GT> | <LE> | <GE> | <EQ> | <NEQ>) thirdprecedence()] }void expression(RecoverySet g) throws ParseEOFException :{}{try {    numexpr() [( <LT> | <GT> | <LE> | <GE> | <EQ> | <NEQ>) numexpr()]}catch (ParseException e){   consumeUntil(g, e, "expression");}}void numexpr() throws ParseEOFException :{}{    term() ((<PLUS> | <MINUS>) term())*}void term() throws ParseEOFException :{}{    unaryexpr() ((<MULTIPLY> | <DIVIDE>| <REM>) unaryexpr())*}//os próximos 2 nao tem especificadovoid thirdprecedence() throws ParseEOFException :{}{    secondprecedence() ((<PLUS> | <MINUS>) secondprecedence())*}void secondprecedence()throws ParseEOFException :{}{    unaryexpr() ((<MULTIPLY> | <DIVIDE>| <REM>) unaryexpr())*}void unaryexpr() throws ParseEOFException :{}{   [(<PLUS> | <MINUS>)] factor()}void factor() throws ParseEOFException :{}{    (        <int_constant> |        <string_constant> |        <null_constant> |       <char_constant > |       <float_constant> |       <boolean_constant> |       lvalue(null) |       <LPAREN> expression(null) <RPAREN>)}void arglist(RecoverySet g) throws ParseEOFException :{RecoverySet f =  new RecoverySet(COMMA).union(g);}{    [expression(f) (<COMMA> expression(f))*]}