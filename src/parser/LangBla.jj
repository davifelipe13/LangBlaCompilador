options {  STATIC = false;  DEBUG_LOOKAHEAD = true;}PARSER_BEGIN(langBla)package parser;import java.io.*;import recovery.*; //importa as classes de recuperação de erros do AS=public class langBla {  	final static String Version = "B+- Compiler - Version 1.0 - 2018";	int contParseError = 0;           // contador de erros sintáticos	boolean debug_recovery;   // controla verbose de recuperação de erros	Token lastError = null;// Define o método "main" da classe langBla.    public  static void main(String args[]) throws ParseException   {	  boolean debug_as = false;	  boolean debug_recovery = false;    String filename = ""; // nome do arquivo a ser analisado    langBla parser;     // analisador léxico/sintático    int i;    boolean ms = false;    System.out.println(Version);    // lê os parâmetros passados para o compilador    for (i = 0; i < args.length - 1; i++)    {        if (args[i].equals("-debug_AS") )            debug_as = true;        else        if (args[i].equals("-debug_recovery") )            debug_recovery = true;        else        {            System.out.println("Usage is: java langBla [-debug_AS] " +             "[-debug_recovery] inputfile");            System.exit(0);        }    }    if (args[i].equals("-"))    {       // lê da entrada padrão              System.out.println("Reading from standard input . . .");        parser = new langBla(System.in); // cria AS     }     else     {       // lê do arquivo        filename = args[args.length-1];          System.out.println("Reading from file " + filename + " . . .");        try {  // cria AS            parser = new langBla(new java.io.FileInputStream(filename));        }     	catch (java.io.FileNotFoundException e) {               System.out.println("File " + filename + " not found.");        return;        }    }     parser.debug_recovery = debug_recovery;    if (! debug_as) parser.disable_tracing(); // desab. verbose do AS    try {        parser.program();   // chama o método que faz a análise    }    catch (ParseEOFException e)    {    System.err.println(e.getMessage());    }    finally {        System.out.println(parser.token_source.foundLexError() +                                " Lexical Errors found");        System.out.println(parser.contParseError + " Syntactic Errors found");     }	}  // main	static public String im(int x)	{	int k;	String s;	   s = tokenImage[x];	   k = s.lastIndexOf("\"");	   try {s = s.substring(1,k);}	   catch (StringIndexOutOfBoundsException e)	   {}	   return s;	}		boolean eof;    // variável que indica se EOF foi alcançado	// o método abaixo consome tokens até alcançar um que pertença ao conjunto	// de sincronização	void consumeUntil(RecoverySet g, ParseException e, String met) throws ParseEOFException, ParseException {		Token tok;		   if ( debug_recovery) // informação sobre a recuperação	   {	       System.out.println();	       System.out.println("*** " + met + " ***");	       System.out.println("     Syncronizing Set: " + g);	   }		   if (g == null) throw e; // se o conjunto é null, propaga a exceção		   tok = getToken(1); // pega token corrente	   while ( ! eof )  // se não chegou ao fim do arquivo	   {	        if ( g.contains(tok.kind ) ) //achou um token no conjunto	        {	             if ( debug_recovery)	               System.out.println("     Found syncronizing token: " + 	                                   im(tok.kind));	             break;	        }	        if (debug_recovery)	             System.out.println("     Ignoring token: " + im(tok.kind));	        getNextToken();     // pega próximo token       	        tok = getToken(1);	        if (tok.kind == EOF && ! g.contains(EOF) ) // fim da entrada?   	            eof = true;	    }	   if ( tok != lastError)	   {	        System.out.println(e.getMessage());	        lastError = tok;	        contParseError++;  // incrementa número de erros	   }	   if ( eof ) throw new ParseEOFException("EOF found prematurely.");	}}  // langBlaPARSER_END(langBla)TOKEN_MGR_DECLS :{int countLexError = 0;public int foundLexError() {    return countLexError;}}SKIP :{  " "| "\r"| "\t"| "\n"| "\f"}SKIP :{  "/*": multilinecomment //ao encontrar um /* o AL vai para o estado multilinecomment, ignorando tudo que venha ate o fim do estado| "//": singlelinecomment}<multilinecomment> SKIP:{  "*/": DEFAULT //ao encontrar um */ acha o fim do estado multilinecomment e volta para o estado padrao do AL| <~[]>}<singlelinecomment> SKIP:{  <["\n","\r"]>: DEFAULT| <~[]>}TOKEN : /* Palavras reservadas */{< BREAK: "break" >| < CLASS: "class" >| < CONSTRUCTOR: "constructor" >| < ELSE: "else" >| < EXTENDS: "extends" >| < FOR: "for" >| < IF: "if" >| < INT: "int" >| < FLOAT: "float" >| < BOOLEAN: "boolean" >| < CHAR : "char" >| < NEW: "new" >| < PRINT: "print" >| < READ: "read" >| < RETURN: "return" >| < STRING: "string" >| < SUPER: "super" >}TOKEN : /* Operadores */{  < ASSIGN: "=">| < GT: ">" >| < LT: "<" >| < EQ: "==" >| < LE: "<=" >| < GE: ">=" >| < NEQ: "!=" >| < PLUS : "+" >| < MINUS : "-" >| < MULTIPLY : "*" > //STAR no livro| < DIVIDE : "/" > //SLASH no livro| < REM: "%" >| < NOT: "not" >| < AND: "and" >| < OR: "or" >| < XOR: "xor" >}TOKEN : /* simbolos especiais */{  < RPAREN: ")" >| < LPAREN: "(" >| < LBRACE: "{" >| < RBRACE: "}" >| < LBRACKET: "[" >| < RBRACKET: "]" >| < SEMICOLON: ";" >| < COMMA: "," >| < DOT: "." > }TOKEN : /* Constantes */{//numeros decimais< int_constant: (  (["0"-"9"] (["0"-"9"])*)) > |// reconhecimento de ponto flutuante, float< float_constant: (  (["0"-"9"] (["0"-"9"])* ["."] ["0"-"9"] (["0"-"9"])*)) > |//reconhecimento de boolean< boolean_constant: "true" | "false" > //reconhecimento de string| < string_constant: "\""( ~["\"","\n","\r"])* "\"" >//reconhecimento de char| < char_constant: "\'"( ~["\'"," ","\r"]) "\'" | "\'" ("\\n") "\'" >// reconhecimento de nulo| < null_constant: "null" > }/* Identificadores */TOKEN:{  < IDENT: < LETTER > (< LETTER >|< DIGIT >)* >| < CONSTANT : (< DIGIT >)+ >| < #LETTER:["A"-"Z","a"-"z"] >| < #DIGIT:["0"-"9"] >}/* Tratamento de erros lexicos */SPECIAL_TOKEN:{<INVALID_LEXICAL:(~ ["a"-"z", "A"-"Z", "0"-"9", "\"", "(", ")", "[", "]", "{", "}", ";", ",", ".", "=", ">", "<", "!", "+", "-","*", "/", "%", " ", "\t", "\n", "\r", "\f","\'"])+ >  {    System.err.println("Line " + input_stream.getEndLine() + " - Invalid string found: " + image);    countLexError++;  }|  <INVALID_CONST:  "\"" (~ ["\n", "\r", "\""])* ["\n", "\r"] >    {    System.err.println("Line " + input_stream.getEndLine() + " - String constant has a \\n: " + image);    countLexError++;  }|    <INVALID_CHAR:     "\'" (~ ["\n", "\'"])* ["\r"] >    {    System.err.println("Line " + input_stream.getEndLine() + " - char constant has a \\r:" + image);    countLexError++;  }|       <EMPTY_CHAR:     "\'" "\'" | "\'"(" ")+"\'">    {    System.err.println("Line " + input_stream.getEndLine() + " - char constant is empty " + image);    countLexError++;  }|  < CHAR_OUT_OF_BOUNDS:    "\'"( ~["\'","\r"])( ~["\'","\r"])+ "\'" >{    System.err.println("Line " + input_stream.getEndLine() + " - char constant is out of bounds " + image);    countLexError++;  }}    //void program() throws ParseEOFException ://{//RecoverySet g = new RecoverySet(EOF);	//}//{//	try{//		[ classlist(g) ] <EOF>//	}//	catch (ParseException e){//		consumeUntil (g, e, "program");//	}//}void program() throws ParseEOFException :{  RecoverySet g = First.program;}{  <EOF>|	classlist(g)  try  {    // [ classlist() ] < EOF > Livro está diferente.    <EOF>  }  catch (ParseException e)  {    consumeUntil(g, e, "program");  }  [ program() ]}void classlist(RecoverySet g) throws ParseEOFException :{RecoverySet f = First.classlist.union(g);}{   classdecl(f) [classlist(g)]}void classdecl(RecoverySet g) throws ParseEOFException :{}{try {   <CLASS>  <IDENT> [ <EXTENDS> <IDENT> ] classbody(g)}catch (ParseException e){    consumeUntil(g, e, "classdecl");}}void classbody(RecoverySet g) throws ParseEOFException :{}{  < LBRACE > [firstcall(g)] <RBRACE >}void firstcall(RecoverySet g) throws ParseEOFException:{}{  recursivecall(g)[firstcall(g)]}void recursivecall(RecoverySet g) throws ParseEOFException:{  RecoverySet f1 = new RecoverySet(RBRACE),			f2 = new RecoverySet(SEMICOLON),            f3 = First.methoddecl.union(f1),            f4 = First.constructdecl.union(f3),            f5 = First.vardecl.union(f4);                        }{  	try {  	  	LOOKAHEAD(3)vardecl(f2) < SEMICOLON >		| 		LOOKAHEAD(3) atribstat(f2) < SEMICOLON >		|		constructdecl(f4)		|		methoddecl(f3)	}	catch (ParseException e) {	   		consumeUntil(g, e, "recursivecall");	}}void vardecl(RecoverySet g) throws ParseEOFException :{}{try {  (<INT> |  <STRING> | <BOOLEAN> |  <CHAR> | <FLOAT> | <IDENT> )    <IDENT> ( <LBRACKET> <RBRACKET>)*   (<COMMA> <IDENT> ( <LBRACKET> <RBRACKET>)* )*  }catch (ParseException e){   consumeUntil(g, e, "vardecl");}}void constructdecl(RecoverySet g) throws ParseEOFException :{}{try {    <CONSTRUCTOR> methodbody(g)}catch (ParseException e){   consumeUntil(g, e, "constructdecl");}}void methoddecl(RecoverySet g) throws ParseEOFException :{}{try {   (<INT> |  <STRING> | <BOOLEAN> | <FLOAT> |  <CHAR> | <IDENT> ) (<LBRACKET> <RBRACKET>)*    <IDENT> methodbody(g)}catch (ParseException e){   consumeUntil(g, e, "methoddecl");}}void methodbody(RecoverySet g) throws ParseEOFException :{RecoverySet f = new RecoverySet(RPAREN);}{try {    <LPAREN> paramlist(f) <RPAREN> statement(g)}catch (ParseException e){   consumeUntil(g, e, "methodbody");}}void paramlist(RecoverySet g) throws ParseEOFException :{}{	try {	   [	    (<INT> |  <STRING> | <FLOAT> | <CHAR> | <BOOLEAN> | <IDENT>) <IDENT> (<LBRACKET> <RBRACKET>)* atribstatparamlist(g)	    ((<COMMA> (<INT> |  <STRING> |  <FLOAT> | <CHAR> | <BOOLEAN> | <IDENT>) <IDENT> (<LBRACKET> <RBRACKET>)* atribstatparamlist(g)))*	   ]	}	catch (ParseException e)	{	   consumeUntil(g, e, "paramlist");	}}void atribstatparamlist(RecoverySet g) throws ParseEOFException:{}{  [<ASSIGN> (alocexpression(g) | expression(g))]}void statement(RecoverySet g) throws ParseEOFException :{RecoverySet f1 = new RecoverySet(SEMICOLON);RecoverySet f2 = new RecoverySet(RBRACE);RecoverySet f3 = First.statlist.union(f1);}{try {    LOOKAHEAD(4)    atribstat(f1)|     vardecl(f1) <SEMICOLON> |    printstat(f1) <SEMICOLON>|    readstat(f1) <SEMICOLON>|    returnstat(f1) <SEMICOLON>|    superstat(f1) <SEMICOLON>|    ifstat(g) |    forstat(g) |    <LBRACE> statlist(f2) <RBRACE> |    <BREAK> <SEMICOLON>|    <SEMICOLON>}catch (ParseException e){   consumeUntil(g, e, "statement");}}void atribstat(RecoverySet g) throws ParseEOFException :{RecoverySet f1 = new RecoverySet(ASSIGN);}{	try {	    LOOKAHEAD(4) lvalue(f1) <ASSIGN> ( alocexpression(g) | expression(g))	  |    (<INT>|<STRING>|<IDENT>|<FLOAT>|<CHAR>|<BOOLEAN>)	      < IDENT >(< LBRACKET > < RBRACKET >)*	       <ASSIGN> (alocexpression(g) | expression(g))	    	}	catch (ParseException e)	{	   consumeUntil(g, e, "atribstat");	}}void printstat(RecoverySet g) throws ParseEOFException :{}{try {    <PRINT> expression(g)}catch (ParseException e){   consumeUntil(g, e, "printstat");}}void readstat(RecoverySet g) throws ParseEOFException :{}{try {    <READ> lvalue(g)}catch (ParseException e){   consumeUntil(g, e, "readstat");}}void returnstat(RecoverySet g) throws ParseEOFException :{}{try {    <RETURN> [expression(g)]}catch (ParseException e){   consumeUntil(g, e, "returnstat");}}void superstat(RecoverySet g) throws ParseEOFException :{RecoverySet f = new RecoverySet(RPAREN);}{try {    <SUPER> <LPAREN> arglist(f) <RPAREN>}catch (ParseException e){   consumeUntil(g, e, "superstat");}}void ifstat(RecoverySet g) throws ParseEOFException :{RecoverySet f1 = new RecoverySet(RPAREN),            f2 = new RecoverySet(ELSE).union(g);}{try {    <IF> <LPAREN> expression(f1) <RPAREN> statement(f2)    [LOOKAHEAD(1) <ELSE> statement(g)]}catch (ParseException e){   consumeUntil(g, e, "ifstat");}}void forstat(RecoverySet g) throws ParseEOFException :{RecoverySet f1 = new RecoverySet(SEMICOLON),            f2 = new RecoverySet(RPAREN);}{try {    <FOR> <LPAREN> [atribstat(f1)] <SEMICOLON>                   [expression(f1)] <SEMICOLON>                   [atribstat(f2)] <RPAREN>                    statement(g)}catch (ParseException e){   consumeUntil(g, e, "forstat");}}void  statlist(RecoverySet g) throws ParseEOFException :{RecoverySet f = First.statlist.union(g);}{   statement(f) [ statlist(g)] }void lvalue(RecoverySet g) throws ParseEOFException :{}{try {   <IDENT> (           <LBRACKET> expression(null) <RBRACKET> |           <DOT> <IDENT> [<LPAREN> arglist(null) <RPAREN>]         )*}catch (ParseException e){   consumeUntil(g, e, "lvalue");}}void alocexpression(RecoverySet g) throws ParseEOFException :{RecoverySet f1 = new RecoverySet(RPAREN),            f2 = new RecoverySet(RBRACKET);}{    <NEW> (             LOOKAHEAD(2) <IDENT> <LPAREN> arglist(f1) <RPAREN> |             ( <INT> | <STRING> | <IDENT> )             (<LBRACKET> expression(f2) <RBRACKET>)+          )} //LIVRO PROGRAM 4.13void firstprecedence() throws ParseEOFException :{}{[<NOT>] fourthprecedence() [(<XOR>|<OR>) [<NOT>] fourthprecedence()]}void fourthprecedence() throws ParseEOFException :{}{  thirdprecedence() [( <LT> | <GT> | <LE> | <GE> | <EQ> | <NEQ>) thirdprecedence()] }void expression(RecoverySet g) throws ParseEOFException :{}{try {   	firstprecedence()(<AND> firstprecedence())*  }catch (ParseException e){   consumeUntil(g, e, "expression");}}void numexpr() throws ParseEOFException :{}{    term() ((<PLUS> | <MINUS>) term())*}void term() throws ParseEOFException :{}{    unaryexpr() ((<MULTIPLY> | <DIVIDE>| <REM>) unaryexpr())*}void thirdprecedence() throws ParseEOFException :{}{    secondprecedence() ((<PLUS> | <MINUS>) secondprecedence())*}void secondprecedence()throws ParseEOFException :{}{    unaryexpr() ((<MULTIPLY> | <DIVIDE>| <REM>) unaryexpr())*}void unaryexpr() throws ParseEOFException :{}{   [(<PLUS> | <MINUS>)] factor()}void factor() throws ParseEOFException :{}{    (        <int_constant> |        <string_constant> |        <null_constant> |       <char_constant > |       <float_constant> |       <boolean_constant> |       lvalue(null) |       <LPAREN> expression(null) <RPAREN>)}void arglist(RecoverySet g) throws ParseEOFException :{RecoverySet f =  new RecoverySet(COMMA).union(g);}{    [expression(f) (<COMMA> expression(f))*]}